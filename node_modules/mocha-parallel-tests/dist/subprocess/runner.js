"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const CircularJSON = require("circular-json");
const Mocha = require("mocha");
const mocha_1 = require("mocha");
const yargs = require("yargs");
const config_1 = require("../config");
const config_2 = require("../config");
const util_1 = require("../util");
const ipc_1 = require("./ipc");
const exit_1 = require("./options/exit");
const full_trace_1 = require("./options/full-trace");
const argv = yargs
    .boolean('bail')
    .option('compilers', {
    array: true,
    default: [],
})
    .boolean('delay')
    .string('grep')
    .boolean('enableTimeouts')
    .option('exit', {
    boolean: true,
})
    .option('full-trace', {
    boolean: true,
})
    .number('slow')
    .option('require', {
    array: true,
    default: [],
})
    .number('retries')
    .number('timeout')
    .parse(process.argv);
const debugSubprocess = argv[config_1.DEBUG_SUBPROCESS.yargs];
const ipc = new ipc_1.default();
class Reporter extends mocha_1.reporters.Base {
    constructor(runner) {
        super(runner);
        /**
         * If `--retries N` option is specified runner can emit `test` events
         * multiple times for retried test cases. These test cases do not exist
         * if the final root suite structure, so we need to store them and return
         * to the main process after the end
         */
        this.runningTests = new Set();
        this.currentTestIndex = null;
        this.onRunnerStart = () => {
            this.notifyParent('start');
        };
        this.onRunnerEnd = () => {
            this.notifyParent('end');
        };
        this.onRunnerSuiteStart = (suite) => {
            const id = util_1.randomId('suite');
            suite[config_1.RUNNABLE_IPC_PROP] = id;
            this.notifyParent('suite', { id });
        };
        this.onRunnerSuiteEnd = (suite) => {
            this.notifyParent('suite end', {
                id: suite[config_1.RUNNABLE_IPC_PROP],
            });
        };
        this.onRunnerWaiting = ( /* rootSuite: ISuite */) => {
            this.notifyParent('waiting');
        };
        this.onTestStart = (test) => {
            const id = util_1.randomId('test');
            test[config_1.RUNNABLE_IPC_PROP] = id;
            // this test is running for the first time, i.e. no retries for it have been executed yet
            if (this.currentTestIndex === null) {
                const currentTestIndex = test.parent.tests.indexOf(test);
                assert(currentTestIndex !== -1, 'Could not find the test in the suite\'s tests');
                this.currentTestIndex = currentTestIndex;
            }
            else if (!test.parent.tests.includes(test)) {
                /**
                 * When mocha runs tests with `--retries` option there's a specific behaviour for events order:
                 * If the test fails and `--retries` = 1, mocha emits `test`, `test`, `fail` and `test end`.
                 * This means that mocha doesn't emit the "test end" event and instead just re-emits the test.
                 * The issue is that the last test in the currently running suite refers to the previously run test.
                 * The fix for us here is to "fix" the mocha old pointer by replacing the failed test with a new one.
                 * NB: This may be a mocha issue
                 */
                test.parent.tests[this.currentTestIndex] = test;
            }
            this.runningTests.add(test);
            this.notifyParent('test', { id });
        };
        this.onTestEnd = (test) => {
            this.runningTests.delete(test);
            this.currentTestIndex = null;
            this.notifyParent('test end', {
                id: test[config_1.RUNNABLE_IPC_PROP],
            });
        };
        this.onRunnerPass = (test) => {
            this.notifyParent('pass', {
                id: test[config_1.RUNNABLE_IPC_PROP],
            });
        };
        this.onRunnerFail = (test, err) => {
            this.notifyParent('fail', {
                err: {
                    message: err.message,
                    name: err.name,
                    stack: err.stack,
                },
                id: test[config_1.RUNNABLE_IPC_PROP],
            });
        };
        this.onRunnerPending = (test) => {
            this.notifyParent('pending', {
                id: test[config_1.RUNNABLE_IPC_PROP],
            });
        };
        this.onRunnerHookStart = (hook) => {
            const id = hook[config_1.RUNNABLE_IPC_PROP] || util_1.randomId('hook');
            hook[config_1.RUNNABLE_IPC_PROP] = id;
            this.notifyParent('hook', { id });
        };
        this.onRunnerHookEnd = (hook) => {
            this.notifyParent('hook end', {
                id: hook[config_1.RUNNABLE_IPC_PROP],
            });
        };
        this.rootSuite = runner.suite;
        runner.on('waiting', this.onRunnerWaiting);
        runner.on('start', this.onRunnerStart);
        runner.on('end', this.onRunnerEnd);
        runner.on('suite', this.onRunnerSuiteStart);
        runner.on('suite end', this.onRunnerSuiteEnd);
        runner.on('test', this.onTestStart);
        runner.on('test end', this.onTestEnd);
        runner.on('pass', this.onRunnerPass);
        runner.on('fail', this.onRunnerFail);
        runner.on('pending', this.onRunnerPending);
        runner.on('hook', this.onRunnerHookStart);
        runner.on('hook end', this.onRunnerHookEnd);
    }
    notifyParent(event, data = {}) {
        if (debugSubprocess) {
            // tslint:disable-next-line:no-console
            console.log({ event, data });
        }
        else {
            this.notifyParentThroughIPC(event, data);
        }
    }
    notifyParentThroughIPC(event, data = {}) {
        // main process needs retried tests only when it starts
        // re-emitting subprocess test results, so it's safe to
        // omit them until the "end" event
        const retriesTests = event === 'end'
            ? [...this.runningTests].map((test) => {
                return Object.assign({}, test, {
                    [config_1.SUBPROCESS_RETRIED_SUITE_ID]: test.parent[config_1.RUNNABLE_IPC_PROP],
                    parent: null,
                });
            })
            : [];
        // send the data snapshot with every event
        ipc.sendEnsureDelivered({
            data: {
                // can't use the root suite because it will not get revived in the master process
                // @see https://github.com/WebReflection/circular-json/issues/44
                results: CircularJSON.stringify({ rootSuite: this.rootSuite }),
                retries: CircularJSON.stringify({ retriesTests }),
            },
            event: 'sync',
        });
        // and then send the event
        ipc.sendEnsureDelivered({ event, data });
    }
}
const mocha = new Mocha();
mocha.addFile(argv.test);
// --compilers
util_1.applyCompilers(argv.compilers);
// --delay
util_1.applyDelay(mocha, argv.delay);
// --grep
util_1.applyGrepPattern(mocha, argv.grep);
// --enableTimeouts
util_1.applyNoTimeouts(mocha, argv.enableTimeouts);
// --exit
const onComplete = exit_1.default(ipc, argv.exit);
// --require
util_1.applyRequires(argv.require);
// --timeout
util_1.applyTimeouts(mocha, argv.timeout);
// --full-trace
full_trace_1.default(mocha, argv.fullTrace);
// apply main process root suite properties
for (const option of config_2.SUITE_OWN_OPTIONS) {
    const suiteProp = `_${option}`;
    mocha.suite[suiteProp] = argv[option];
}
mocha.reporter(Reporter).run(onComplete);
//# sourceMappingURL=runner.js.map