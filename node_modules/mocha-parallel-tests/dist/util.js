"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const path_1 = require("path");
function randomId(prefix) {
    return `${prefix}-${crypto_1.randomBytes(16).toString('hex')}`;
}
exports.randomId = randomId;
function setProcessExitListeners() {
    process.on('unhandledRejection', (reason) => {
        // tslint:disable-next-line:no-console
        console.error(`Unhandled asynchronous exception: ${reason.stack}`);
        process.exit(1);
    });
    process.on('uncaughtException', (err) => {
        // tslint:disable-next-line:no-console
        console.error(`Uncaught exception: ${err.stack}`);
        process.exit(1);
    });
}
exports.setProcessExitListeners = setProcessExitListeners;
function applyRequires(requires) {
    const requiresList = Array.isArray(requires) ? requires : [requires];
    const output = [];
    // required file can be in the process CWD
    const cwd = process.cwd();
    module.paths.push(cwd, path_1.join(cwd, 'node_modules'));
    for (const mod of requiresList) {
        const abs = fs_1.existsSync(mod) || fs_1.existsSync(`${mod}.js`);
        const requirePath = abs ? path_1.resolve(mod) : mod;
        require(requirePath);
        output.push(requirePath);
    }
    return output;
}
exports.applyRequires = applyRequires;
function applyCompilers(compilers) {
    const compilersList = Array.isArray(compilers) ? compilers : [compilers];
    const output = {
        compilers: compilersList,
        extensions: ['js'],
    };
    // required compiler can be in the process CWD
    const cwd = process.cwd();
    module.paths.push(cwd, path_1.join(cwd, 'node_modules'));
    for (const compiler of compilersList) {
        const idx = compiler.indexOf(':');
        const ext = compiler.slice(0, idx);
        let mod = compiler.slice(idx + 1);
        if (mod.startsWith('.')) {
            mod = path_1.join(process.cwd(), mod);
        }
        require(mod);
        output.extensions.push(ext);
    }
    return output;
}
exports.applyCompilers = applyCompilers;
function applyDelay(mocha, delay) {
    if (delay) {
        mocha.delay();
    }
}
exports.applyDelay = applyDelay;
function applyGrepPattern(mocha, stringPattern) {
    if (stringPattern) {
        mocha.grep(stringPattern);
    }
}
exports.applyGrepPattern = applyGrepPattern;
function applyNoTimeouts(mocha, allowTimeouts) {
    if (allowTimeouts === false) {
        mocha.enableTimeouts(false);
    }
}
exports.applyNoTimeouts = applyNoTimeouts;
function applyTimeouts(mocha, timeout) {
    if (timeout) {
        mocha.suite.timeout(timeout);
    }
}
exports.applyTimeouts = applyTimeouts;
//# sourceMappingURL=util.js.map