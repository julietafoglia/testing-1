"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const CircularJSON = require("circular-json");
const debug = require("debug");
const Mocha = require("mocha");
const path_1 = require("path");
const runner_1 = require("./runner");
const task_manager_1 = require("./task-manager");
const util_1 = require("./util");
const config_1 = require("../config");
const debugLog = debug('mocha-parallel-tests');
class MochaWrapper extends Mocha {
    constructor() {
        super(...arguments);
        this.isTypescriptRunMode = false;
        this.requires = [];
        this.compilers = [];
        this.exitImmediately = false;
    }
    setTypescriptRunMode() {
        this.isTypescriptRunMode = true;
    }
    /**
     * All `--require` options should be applied for subprocesses
     */
    addRequiresForSubprocess(requires) {
        this.requires = requires;
    }
    /**
     * All `--compiler` options should be applied for subprocesses
     */
    addCompilersForSubprocess(compilers) {
        this.compilers = compilers;
    }
    setMaxParallel(maxParallel) {
        this.maxParallel = maxParallel;
    }
    enableExitMode() {
        this.exitImmediately = true;
        return this;
    }
    run(onComplete) {
        const { asyncOnly, ignoreLeaks, forbidOnly, forbidPending, fullStackTrace, hasOnly, } = this.options;
        const rootSuite = this.suite;
        const runner = new runner_1.default(rootSuite);
        runner.ignoreLeaks = ignoreLeaks !== false;
        runner.forbidOnly = forbidOnly;
        runner.forbidPending = forbidPending;
        runner.hasOnly = hasOnly;
        runner.fullStackTrace = fullStackTrace;
        runner.asyncOnly = asyncOnly;
        const taskManager = new task_manager_1.default(this.maxParallel);
        for (const file of this.files) {
            const task = () => this.spawnTestProcess(file);
            taskManager.add(task);
        }
        this.options.files = this.files;
        // Refer to mocha lib/mocha.js run() method for more info here
        const reporter = new this._reporter(runner, this.options);
        // emit `start` and `suite` events
        // so that reporters can record the start time
        runner.emitStartEvents();
        taskManager.execute();
        taskManager
            .on('taskFinished', (testResults) => {
            const { code, execTime, events, file, syncedSubprocessData, } = testResults;
            debugLog(`File execution finished: ${file}`);
            // tslint:disable-next-line:max-line-length
            debugLog(`Has synced data: ${Boolean(syncedSubprocessData)}, number of events: ${events.length}, execution time: ${execTime}`);
            const retriedTests = [];
            if (syncedSubprocessData) {
                this.addSubprocessSuites(testResults);
                retriedTests.push(...this.extractSubprocessRetriedTests(testResults));
            }
            runner.reEmitSubprocessEvents(testResults, retriedTests);
            const hasEndEvent = events.find((event) => event.type === 'runner' && event.event === 'end');
            if (!hasEndEvent && code !== 0) {
                process.exit(code);
            }
        })
            .on('end', () => {
            debugLog('All tests finished processing');
            const done = (failures) => {
                if (reporter.done) {
                    reporter.done(failures, onComplete);
                }
                else if (onComplete) {
                    onComplete(failures);
                }
            };
            runner.emitFinishEvents(done);
        });
        return runner;
    }
    addSubprocessSuites(testArtifacts) {
        const rootSuite = this.suite;
        const serialized = testArtifacts.syncedSubprocessData;
        const { rootSuite: testRootSuite } = CircularJSON.parse(serialized.results, util_1.subprocessParseReviver);
        Object.assign(testRootSuite, {
            parent: rootSuite,
            root: false,
        });
        rootSuite.suites.push(testRootSuite);
    }
    extractSubprocessRetriedTests(testArtifacts) {
        const serialized = testArtifacts.syncedSubprocessData;
        const { retriesTests } = CircularJSON.parse(serialized.retries, util_1.subprocessParseReviver);
        return retriesTests;
    }
    spawnTestProcess(file) {
        return new Promise((resolve) => {
            const nodeFlags = [];
            const extension = this.isTypescriptRunMode ? 'ts' : 'js';
            const runnerPath = path_1.resolve(__dirname, `../subprocess/runner.${extension}`);
            const resolvedFilePath = path_1.resolve(file);
            const forkArgs = ['--test', resolvedFilePath];
            for (const option of config_1.SUITE_OWN_OPTIONS) {
                const propValue = this.suite[option]();
                // bail is undefined by default, we need to somehow pass its value to the subprocess
                forkArgs.push(`--${option}`, propValue === undefined ? false : propValue);
            }
            for (const requirePath of this.requires) {
                forkArgs.push('--require', requirePath);
            }
            for (const compilerPath of this.compilers) {
                forkArgs.push('--compilers', compilerPath);
            }
            if (this.options.delay) {
                forkArgs.push('--delay');
            }
            if (this.options.grep) {
                forkArgs.push('--grep', this.options.grep.toString());
            }
            if (this.exitImmediately) {
                forkArgs.push('--exit');
            }
            if (this.options.fullStackTrace) {
                forkArgs.push('--full-trace');
            }
            const test = child_process_1.fork(runnerPath, forkArgs, {
                // otherwise `--inspect-brk` and other params will be passed to subprocess
                execArgv: process.execArgv.filter(util_1.removeDebugArgs),
                stdio: ['ipc'],
            });
            if (this.isTypescriptRunMode) {
                nodeFlags.push('--require', 'ts-node/register');
            }
            debugLog('Process spawned. You can run it manually with this command:');
            debugLog(`node ${nodeFlags.join(' ')} ${runnerPath} ${forkArgs.concat([config_1.DEBUG_SUBPROCESS.argument]).join(' ')}`);
            const events = [];
            let syncedSubprocessData;
            const startedAt = Date.now();
            test.on('message', function onMessageHandler({ event, data }) {
                if (event === 'sync') {
                    syncedSubprocessData = data;
                }
                else {
                    events.push({
                        data,
                        event,
                        type: 'runner',
                    });
                }
            });
            test.stdout.on('data', function onStdoutData(data) {
                events.push({
                    data,
                    event: undefined,
                    type: 'stdout',
                });
            });
            test.stderr.on('data', function onStderrData(data) {
                events.push({
                    data,
                    event: undefined,
                    type: 'stderr',
                });
            });
            test.on('close', (code) => {
                debugLog(`Process for ${file} exited with code ${code}`);
                resolve({
                    code,
                    events,
                    execTime: Date.now() - startedAt,
                    file,
                    syncedSubprocessData,
                });
            });
        });
    }
}
exports.default = MochaWrapper;
//# sourceMappingURL=mocha.js.map