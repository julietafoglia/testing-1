#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yargs = require("yargs");
const mocha_1 = require("../main/mocha");
const util_1 = require("../util");
const async_only_1 = require("./options/async-only");
const bail_1 = require("./options/bail");
const check_leaks_1 = require("./options/check-leaks");
const compilers_1 = require("./options/compilers");
const delay_1 = require("./options/delay");
const exit_1 = require("./options/exit");
const forbid_only_1 = require("./options/forbid-only");
const forbid_pending_1 = require("./options/forbid-pending");
const full_trace_1 = require("./options/full-trace");
const grep_1 = require("./options/grep");
const max_parallel_1 = require("./options/max-parallel");
const no_timeouts_1 = require("./options/no-timeouts");
const reporter_1 = require("./options/reporter");
const reporter_options_1 = require("./options/reporter-options");
const require_1 = require("./options/require");
const rest_1 = require("./options/rest");
const retries_1 = require("./options/retries");
const slow_1 = require("./options/slow");
const timeout_1 = require("./options/timeout");
util_1.setProcessExitListeners();
// --opts changes process.argv so it should be executed first
// tslint:disable-next-line:no-var-requires
const getOptions = require('mocha/bin/options');
getOptions();
const mocha = new mocha_1.default();
const argv = yargs
    .option('async-only', {
    alias: 'A',
    boolean: true,
})
    .option('bail', {
    alias: 'b',
    boolean: true,
})
    .option('check-leaks', {
    boolean: true,
})
    .option('compilers', {
    default: [],
})
    .option('delay', {
    boolean: true,
})
    .option('exit', {
    boolean: true,
})
    .option('forbidOnly', {
    boolean: true,
})
    .option('forbidPending', {
    boolean: true,
})
    .option('full-trace', {
    boolean: true,
})
    .option('max-parallel', {
    number: true,
})
    .option('grep', {
    alias: 'g',
    string: true,
})
    .option('recursive', {
    boolean: true,
})
    .option('reporter', {
    alias: 'R',
    default: 'spec',
    string: true,
})
    .option('reporter-options', {
    alias: 'O',
    string: true,
})
    .option('retries', {
    number: true,
})
    .option('require', {
    alias: 'r',
    default: [],
})
    .option('slow', {
    alias: 's',
    number: true,
})
    .option('timeout', {
    alias: 't',
    number: true,
})
    .parse(process.argv);
// --async-only
async_only_1.default(mocha, argv.asyncOnly);
// --bail
bail_1.default(mocha, argv.bail);
// --check-leaks
check_leaks_1.default(mocha, argv.checkLeaks);
// --compilers
const { compilers, extensions } = compilers_1.default(argv.compilers);
mocha.addCompilersForSubprocess(compilers);
// --delay
delay_1.default(mocha, argv.delay);
// --exit
exit_1.default(mocha, argv.exit);
// --forbid-only
forbid_only_1.default(mocha, argv.forbidOnly);
// --forbid-pending
forbid_pending_1.default(mocha, argv.forbidPending);
// --full-trace
full_trace_1.default(mocha, argv.fullTrace);
// --grep option
grep_1.default(mocha, argv.grep);
// --max-parallel
max_parallel_1.default(mocha, argv.maxParallel);
// --no-timeouts
no_timeouts_1.default(mocha, argv.timeouts);
// --r, --require
const requires = require_1.default(argv.require);
mocha.addRequiresForSubprocess(requires);
// --reporter-options
const reporterOptions = argv.reporterOptions !== undefined
    ? reporter_options_1.default(argv.reporterOptions)
    : {};
// --reporter
reporter_1.default(mocha, argv.reporter, reporterOptions);
// --retries
retries_1.default(mocha, argv.retries);
// --slow
slow_1.default(mocha, argv.slow);
// --timeout
timeout_1.default(mocha, argv.timeout);
// find files
const files = rest_1.default(argv._.slice(2), extensions, argv.recursive);
if (!files.length) {
    // tslint:disable-next-line:no-console
    console.error('No test files found');
    process.exit(1);
}
for (const file of files) {
    mocha.addFile(file);
}
const isTypescriptRun = argv.$0.endsWith('.ts');
if (isTypescriptRun) {
    mocha.setTypescriptRunMode();
}
mocha.run((code) => {
    process.on('exit', function onExit() {
        process.exit(Math.min(code, 255));
    });
});
//# sourceMappingURL=cli.js.map